import math
import random

def line_intersects_circle(x1, y1, x2, y2, cx, cy, radius):
    dx = x2 - x1
    dy = y2 - y1
    denominator = dx*dx + dy*dy

    if denominator == 0:
        distance = math.sqrt((x1 - cx)**2 + (y1 - cy)**2)
        return distance <= radius

    t = ((cx - x1) * dx + (cy - y1) * dy) / denominator
    t = max(0, min(1, t))
    closest_x = x1 + t * dx
    closest_y = y1 + t * dy
    distance = math.sqrt((closest_x - cx)**2 + (closest_y - cy)**2)
    return distance <= radius

def fitness(path):
    cx, cy, radius = 5, 5, 2
    collisions = 0
    for i in range(len(path) - 1):
        if line_intersects_circle(path[i][0], path[i][1], path[i+1][0], path[i+1][1], cx, cy, radius):
            collisions += 1
    return collisions

def get_random_path(num_points=5, x_range=(0,10), y_range=(0,10)):
    return [(random.uniform(*x_range), random.uniform(*y_range)) for _ in range(num_points)]

def levy_flight(path, alpha=0.1):
    new_path = []
    for (x, y) in path:
        step_x = alpha * random.gauss(0, 1)
        step_y = alpha * random.gauss(0, 1)
        new_path.append((x + step_x, y + step_y))
    return new_path

def abandon_worst_paths(paths, pa=0.25):
    n = len(paths)
    num_abandon = int(pa * n)
    paths_fitness = [(p, fitness(p)) for p in paths]
    paths_fitness.sort(key=lambda x: x[1], reverse=True)
    for i in range(num_abandon):
        new_path = get_random_path()
        paths_fitness[i] = (new_path, fitness(new_path))
    paths_fitness.sort(key=lambda x: x[1])
    return [pf[0] for pf in paths_fitness]

def cuckoo_search(num_paths=10, num_iterations=100):
    paths = [get_random_path() for _ in range(num_paths)]
    best_path = paths[0]
    best_score = fitness(best_path)

    for _ in range(num_iterations):
        new_paths = []
        for path in paths:
            new_path = levy_flight(path)
            if fitness(new_path) < fitness(path):
                new_paths.append(new_path)
            else:
                new_paths.append(path)

        paths = new_paths

        for path in paths:
            current_score = fitness(path)
            if current_score < best_score:
                best_path = path
                best_score = current_score

        paths = abandon_worst_paths(paths)

    return best_path, best_score

if __name__ == "__main__":
    best_path, best_collisions = cuckoo_search()
    print("Best fitness:", best_collisions)
    print("Best solution:", [(round(p[0], 6), round(p[1], 6)) for p in best_path])
