import numpy as np

def fitness_function(position):
    x, y = position
    return x**2 + y**2

num_particles = 30
num_dimensions = 2
num_iterations = 100

w = 0.7
c1 = 1.5
c2 = 1.5

lower_bound = -10
upper_bound = 10

class Particle:
    def __init__(self):
        self.position = np.random.uniform(lower_bound, upper_bound, num_dimensions)
        self.velocity = np.random.uniform(-1, 1, num_dimensions)
        self.best_position = np.copy(self.position)
        self.best_score = fitness_function(self.position)

    def update_velocity(self, global_best_position):
        r1 = np.random.rand(num_dimensions)
        r2 = np.random.rand(num_dimensions)
        cognitive = c1 * r1 * (self.best_position - self.position)
        social = c2 * r2 * (global_best_position - self.position)
        self.velocity = w * self.velocity + cognitive + social

    def update_position(self):
        self.position += self.velocity
        self.position = np.clip(self.position, lower_bound, upper_bound)

    def evaluate(self):
        score = fitness_function(self.position)
        if score < self.best_score:
            self.best_score = score
            self.best_position = np.copy(self.position)
        return score

swarm = [Particle() for _ in range(num_particles)]

global_best_position = swarm[0].best_position
global_best_score = swarm[0].best_score

for iteration in range(num_iterations):
    for particle in swarm:
        score = particle.evaluate()
        if score < global_best_score:
            global_best_score = score
            global_best_position = np.copy(particle.position)
    for particle in swarm:
        particle.update_velocity(global_best_position)
        particle.update_position()
    print(f"Iteration {iteration+1}/{num_iterations}, Best Score: {global_best_score:.6f}")

print("\nBest position (weights):", global_best_position)
print("Minimum value of f(x, y):", global_best_score)
