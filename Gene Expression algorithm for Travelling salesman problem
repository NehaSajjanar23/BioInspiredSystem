import random
import numpy as np

cities = [(0,0), (1,2), (4,3), (5,5)]

def distance(a, b):
    return np.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2)

def total_distance(route):
    dist = sum(distance(cities[route[i]], cities[route[i+1]]) for i in range(len(route)-1))
    dist += distance(cities[route[-1]], cities[route[0]])
    return dist

pop_size = 10
generations = 30
mutation_rate = 0.1

def init_population():
    base = list(range(len(cities)))
    return [random.sample(base, len(base)) for _ in range(pop_size)]

def fitness(route):
    return 1 / total_distance(route)

def tournament_selection(pop, fits):
    tournament = random.sample(list(zip(pop, fits)), 3)
    return max(tournament, key=lambda x: x[1])[0]

def order_crossover(p1, p2):
    if random.random() > 0.8:
        start, end = sorted(random.sample(range(len(p1)), 2))
        child = [-1]*len(p1)
        child[start:end+1] = p1[start:end+1]
        pos = (end+1) % len(p1)
        for city in p2:
            if city not in child:
                child[pos] = city
                pos = (pos + 1) % len(p1)
        return child
    else:
        return p1[:]

def mutate(route):
    if random.random() < mutation_rate:
        i, j = random.sample(range(len(route)), 2)
        route[i], route[j] = route[j], route[i]
    return route

population = init_population()

best_route = None
best_fit = 0

for _ in range(generations):
    fits = [fitness(route) for route in population]
    new_pop = []
    for _ in range(pop_size):
        p1 = tournament_selection(population, fits)
        p2 = tournament_selection(population, fits)
        child = order_crossover(p1, p2)
        child = mutate(child)
        new_pop.append(child)
    population = new_pop

    max_fit = max(fits)
    if max_fit > best_fit:
        best_fit = max_fit
        best_route = population[fits.index(max_fit)]

print("Best Route:", best_route)
print(f"Total Distance: {total_distance(best_route):.2f}")
